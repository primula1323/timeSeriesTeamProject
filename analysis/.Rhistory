ggtitle(paste("Forecast vs Actual for", model_object$series)) +
theme_minimal()
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
print(fc_result$forecast_obj)
View(fc_result)
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
autoplot(fc) + # ggplot2 기반 시각화
autolayer(actual_future_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_object$series)) +
theme_minimal()
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
print(fc_result$forecast_obj)
# 예측 결과 시각화
plot(forecast_arima,
main = paste0(colname, "에 대한 사교육비 예측 결과"),
xlab = "연도",
ylab = "사교육비 (CPI 조정)")
lines(real_data, col = 'red', lwd = 2)
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
autoplot(fc) + # ggplot2 기반 시각화
autolayer(actual_future_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_object$series)) +
theme_minimal()
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
print(fc_result$forecast_obj)
# 예측 결과 시각화
plot(forecast_arima,
main = paste0(colname, "에 대한 사교육비 예측 결과"),
xlab = "연도",
ylab = "사교육비 (CPI 조정)")
lines(real_data, col = 'red', lwd = 2)
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
autoplot(fc) + # ggplot2 기반 시각화
autolayer(actual_future_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_object$series)) +
theme_minimal()
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
print(fc_result$forecast_obj)
forecast_and_evaluate(model_auto_arima, real_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
View(fc_result)
theme_minimal()
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_log_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
colname <- 'adj_adult'
ts_data <- to_ts(colname)
real_data <- to_ts_test(colname)
ts_log_data <- log(ts_data)
real_log_data <- log(real_data)
plot(ts_data, main = paste0('Time series Plot for ', colname))
plot(decompose(ts_data, type="additive"))
model_auto_arima <- auto.arima(ts_data, trace = TRUE)
print(model_auto_arima)
acf(ts_data, main = paste("ACF for", colname))
pacf(ts_data, main = paste("PACF for", colname))
adf.test(ts_data)
acf(diff(ts_data), main = paste("ACF for", colname))
pacf(diff(ts_data), main = paste("PACF for", colname))
adf.test(diff(ts_data))
checkresiduals(model_auto_arima)
acf(ts_log_data, main = paste("ACF for", colname))
pacf(ts_log_data, main = paste("PACF for", colname))
adf.test(ts_log_data)
model_log_auto_arima <- auto.arima(ts_data, trace = TRUE)
print(model_log_auto_arima)
acf(diff(ts_log_data), main = paste("ACF for", colname))
pacf(diff(ts_log_data), main = paste("PACF for", colname))
adf.test(diff(ts_log_data))
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_log_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
real_log_data
View(fc_log_result)
View(model_auto_arima)
View(model_log_auto_arima)
model_log_auto_arima <- auto.arima(ts_log_data, trace = TRUE)
print(model_log_auto_arima)
acf(diff(ts_log_data), main = paste("ACF for", colname))
pacf(diff(ts_log_data), main = paste("PACF for", colname))
adf.test(diff(ts_log_data))
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_log_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
forecast_and_evaluate <- function(model_object, actual_future_data) {
#예측 기간 설정
forecast_years <- 2017:2023
forecast_quarters <- 1:4
forecast_length <- length(forecast_years) * length(forecast_quarters)
#예측
fc <- forecast(model_object, h = forecast_length)
if (!is.null(actual_future_data)) {
print(accuracy(fc, actual_future_data))
return(list(forecast_object = fc, accuracy_metrics = accuracy(fc, actual_future_data)))
} else {
return(list(forecast_object = fc, accuracy_metrics = NULL))
}
}
fc_result <- forecast_and_evaluate(model_auto_arima, real_data)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
autoplot(fc_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
autoplot(exp(fc_log_result$forecast_obj)) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
exp(fc_log_result$forecast_obj)
fc_log_result$forecast_object
fc_log_result$forecast_obj$`Point Forecast`
fc_log_result$forecast_obj
ColNames(fc_log_result$forecast_obj)
colnames(fc_log_result$forecast_obj)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
View(fc_log_result)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(train_data_original_scale_ts, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(forecast_mean_original_scale, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data_original_scale, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", original_series_name, "(Original Scale)")) +
xlab("연도") +
ylab(paste(original_series_name, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(real_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(real_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data_original_scale, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", original_series_name, "(Original Scale)")) +
xlab("연도") +
ylab(paste(original_series_name, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(ts_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(ts_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", original_series_name, "(Original Scale)")) +
xlab("연도") +
ylab(paste(original_series_name, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_data, series = "Actual Log Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(ts_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(ts_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", colname, "(Original Scale)")) +
xlab("연도") +
ylab(paste(colname, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(ts_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(ts_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", colname, "(Original Scale)")) +
xlab("연도") +
ylab(paste(colname, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(ts_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(ts_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", colname, "(Original Scale)")) +
xlab("연도") +
ylab(paste(colname, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
forecast_mean_original_scale <- exp(fc_log_result$forecast_obj$mean)
forecast_lower_original_scale <- exp(fc_log_result$forecast_obj$lower)
forecast_upper_original_scale <- exp(fc_log_result$forecast_obj$upper)
gg_plot_original_scale <- ggplot() +
# (검은선) 원본 훈련 데이터 (원래 스케일)
autolayer(ts_data, series = "Original Data", color = "black", linetype = "solid") +
# (파란선) 예측 평균 (원래 스케일)
autolayer(ts_data, series = "Forecast Data", color = "blue", linetype = "solid", PI = FALSE) +
# 예측 신뢰구간 (원래 스케일) - geom_ribbon 사용
geom_ribbon(aes(x = time(forecast_mean_original_scale), # x축은 예측 평균의 시간축 사용
ymin = forecast_lower_original_scale,
ymax = forecast_upper_original_scale,
fill = "Forecast Interval"), # 범례 항목을 위한 fill 매핑
alpha = 0.3) + # 투명도 조절
# (빨간선) 실제 미래 데이터 (원래 스케일)
autolayer(real_data, series = "Real Data", color = "red", linetype = "solid") +
# 그래프 제목 및 축 레이블
ggtitle(paste("Forecast vs Actual for", colname, "(Original Scale)")) +
xlab("연도") +
ylab(paste(colname, "(Original Scale)")) +
# 범례 색상 및 이름 수동 설정
scale_color_manual(name = "데이터 종류", # 범례 제목
values = c("Original Data" = "black",
"Forecast Data" = "blue",
"Real Data" = "red"),
breaks = c("Original Data", "Forecast Data", "Real Data")) + # 범례 순서 및 항목 지정
# 신뢰구간 fill 색상 및 범례 설정
scale_fill_manual(name = "", # 신뢰구간 범례 제목 (보통 비워둠)
values = c("Forecast Interval" = "lightblue"), # 신뢰구간 색상
labels = c("95% Prediction Interval")) + # 신뢰구간 범례 레이블 (forecast 객체의 기본 레벨에 따라 조절)
# 테마 적용
theme_minimal() +
theme(legend.position = "top")
print(gg_plot_original_scale)
fc_log_result <- forecast_and_evaluate(model_log_auto_arima, real_log_data)
autoplot(fc_log_result$forecast_obj) + # ggplot2 기반 시각화
autolayer(real_log_data, series = "Actual Data") +
ggtitle(paste("Forecast vs Actual for", model_auto_arima$series)) +
theme_minimal()
